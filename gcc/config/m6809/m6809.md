;; GCC machine description for Motorola 6809
;; Copyright (C) 1989, 2005, 2006, 2007, 2008,
;; 2009 Free Software Foundation, Inc.
;;
;; Mostly by Brian Dominy (brian@oddchange.com)
;;
;; Based on earlier work by Tom Jones (jones@sal.wisc.edu) and
;; Matthias Doerfel (msdoerfe@informatik.uni-erlangen.de)
;;
;; This file is part of GCC.
;;
;; GCC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.
;;
;; GCC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.
;;
;; General information:
;; --------------------
;; * This backend is mostly a rewrite from earlier (3.1.1 and before)
;; versions.
;;
;; * The 'A' and 'B' registers are treated as a single register by the
;; register allocator; hence, the instruction templates assume that
;; both can be modified if either one is available for use.  No
;; attempt is made to split instructions to refer to a particular half
;; of the register.  It is always referred to as the 'D' register, even
;; in QImode (when it will be displayed as 'B').
;;
;; * There is full support for proper branch instruction generation,
;; based on instruction lengths.  However, many instruction patterns
;; are still overloaded to emit lots of real instructions, which can
;; make the length calculation difficult; in those cases, I've tried
;; to be pessimistic and assume the worst-case.
;;
;; * The instruction type attributes are only defined for branch
;; vs. non branch instructions for now, since there is seemingly no
;; reason to define these for other types anyway.
;;
;; * The limited number of total registers presents the greatest
;; challenge.  There are 'soft registers' -- memory locations
;; used to simulate real regs -- which can be helpful.
;;
;; * Position-independent code (PIC) is supported and has been tested
;; but not to the extent of absolute code generation.
;;
;; * All of the 6809 special opcodes, e.g. SWI and SYNC, are defined
;; as UNSPEC instructions, and can be accessed from C code using
;; __builtin_xxxx() style functions.
;;
;; What still needs to be done:
;; ----------------------------
;; * Replace remaining instances of (define_peephole) with
;; (define_peephole2), or remove them completely if they are not
;; matching anyway.  Add more peepholes for things actually encountered.
;;
;; * Indexing addressing can lead to crashes in complex functions when
;; register pressure is high.  Only the 'D' register can actually be
;; used as an index register, and its demand by other instructions
;; can sometimes mean that it is impossible to satisfy constraints.
;; Currently, indexing is completely disabled to avoid these types
;; of problems, although code is slightly more inefficient in some
;; working cases.
;;
;; * 32-bit math is terribly inefficient.
;;


;;--------------------------------------------------------------------
;;-  Constants
;;--------------------------------------------------------------------

;
; Define constants for hard register numbers.
;
(define_constants [
  (HARD_RSVD1_REGNUM 0)
  (HARD_X_REGNUM 1) (HARD_Y_REGNUM 2) (HARD_U_REGNUM 3)
  (HARD_S_REGNUM 4) (HARD_PC_REGNUM 5) (HARD_D_REGNUM 6)
  (HARD_Z_REGNUM 7)
  (HARD_A_REGNUM 8) (HARD_B_REGNUM 9)
  (HARD_CC_REGNUM 10) (HARD_DP_REGNUM 11)
  (SOFT_FP_REGNUM 12) (SOFT_AP_REGNUM 13)
  (SOFT_M0_REGNUM 14) (SOFT_M1_REGNUM 15)
  (SOFT_M2_REGNUM 16) (SOFT_M3_REGNUM 17)
])


;
; The range in which a short branch insn can be used.
;
(define_constants [
  (MIN_SHORT_BRANCH_OFFSET -127)
  (MAX_SHORT_BRANCH_OFFSET 128)
])


;
; The lengths of various types of real 6809 instructions.
;
; By default, ordinary insns are 4 bytes long.  This is often not
; right, and the insn patterns below will redefine this to the
; correct value.
;
; Branch instruction lengths (conditional and unconditionals) are
; well known and declared here.  The short insns are used when the
; offset is within the range declared above (between MIN_SHORT
; and MAX_SHORT) ; otherwise the long form is used.
;
(define_constants [
  (DEFAULT_INSN_LENGTH 4)
  (SHORT_CBRANCH_LENGTH 2)
  (LONG_CBRANCH_LENGTH 4)
  (SHORT_BRANCH_LENGTH 2)
  (LONG_BRANCH_LENGTH 3)
])


;
; Constants for insn cycle counts.
; Note that these counts all assume 1-byte opcodes.  2-byte
; opcodes require 1 extra cycles for fetching the extra byte.
;
(define_constants [
  ;; The default insn length, when it cannot be calculated.
  ;; Take a conservative approach and estimate high.
  (DEFAULT_INSN_CYCLES 10)

  ;; Cycle counts for ALU and load operations.
  (ALU_INHERENT_CYCLES 2)
  (ALU_IMMED_CYCLES 2)
  (ALU_DIRECT_CYCLES 4)
  (ALU_INDEXED_BASE_CYCLES 4)
  (ALU_EXTENDED_CYCLES 5)

  ;; If an ALU operation is on a 16-bit register (D), then
  ;; add this number of cycles to the total count.
  (ALU_16BIT_CYCLES 2)

  ;; A load of a 16-bit register incurs this extra amount.
  (LOAD_16BIT_CYCLES 1)

  ;; Cycle counts for memory-only operations (bit shifts, clear, test)
  (MEM_DIRECT_CYCLES 6)
  (MEM_INDEXED_BASE_CYCLES 6)
  (MEM_EXTENDED_CYCLES 7)

  ;; Cycle count for any reg-reg transfer (regardless of size)
  (EXG_CYCLES 8)
  (TFR_CYCLES 6)

  ;; Cycle count for a condition code update (andcc/orcc)
  (CC_CYCLES 3)

  (JMP_DIRECT_CYCLES 3)
  (JMP_INDEXED_BASE_CYCLES 3)
  (JMP_EXTENDED_CYCLES 4)

  (JSR_DIRECT_CYCLES 7)
  (JSR_INDEXED_BASE_CYCLES 7)
  (JSR_EXTENDED_CYCLES 8)

  (LEA_BASE_CYCLES 4)

  ;; Cycle count for a psh/pul operations.  Add to this the
  ;; total number of bytes moved for the correct count.
  (PSH_PUL_CYCLES 5)

  ;; Miscellaneous cycle counts
  (CWAI_CYCLES 20)
  (MUL_CYCLES 11)
  (NOP_CYCLES 2)
  (RTI_CYCLES 15)
  (RTS_CYCLES 5)
  (SWI_CYCLES 20)
  (SYNC_CYCLES 4)
])


;
; An enumeration of values for each "unspec"; i.e. unspecified
; instruction.  These represent insns that are meaningful on the
; 6809 but which have no intrinsic meaning to GCC itself.
; These insns can be generated explicitly using the __builtin_xxx
; syntax; they are also implicitly generated by the backend
; as needed to implement other insns.
;
(define_constants [
  (UNSPEC_BLOCKAGE 0)
  (UNSPEC_PUSH_RS 1)
  (UNSPEC_POP_RS 2)
  (UNSPEC_SWI 3)
  (UNSPEC_CWAI 4)
  (UNSPEC_ADD_CARRY 5)
  (UNSPEC_SUB_CARRY 6)
  (UNSPEC_SYNC 7)
  (UNSPEC_ADD_DECIMAL 8)
  (UNSPEC_MUL 9)
])


;;--------------------------------------------------------------------
;;-  Predicates
;;--------------------------------------------------------------------

(include "predicates.md")

;;--------------------------------------------------------------------
;;-  Attributes
;;--------------------------------------------------------------------

;;
;; The type attribute is used to distinguish between different
;; types of branch instructions, so that their lengths can be
;; calculated correctly.
;;
(define_attr "type" "branch,cbranch,unknown" (const_string "unknown"))

;;
;; The length of a branch instruction is calculated based on how
;; far away the branch target is.  Lengths of other insns default
;; to 4.  set_attr is used in instruction templates to specify
;; the length when it is known exactly.  When not sure, err on
;; the high side to avoid compile errors.
;;
(define_attr "length" ""
  (cond [
    (eq_attr "type" "branch")
    (if_then_else (lt (minus (match_dup 0) (pc))
                      (const_int MIN_SHORT_BRANCH_OFFSET))
      (const_int LONG_BRANCH_LENGTH)
        (if_then_else (gt (minus (match_dup 0) (pc))
                          (const_int MAX_SHORT_BRANCH_OFFSET))
          (const_int LONG_BRANCH_LENGTH)
          (const_int SHORT_BRANCH_LENGTH)))
    (eq_attr "type" "cbranch")
    (if_then_else (lt (minus (match_dup 0) (pc))
                      (const_int MIN_SHORT_BRANCH_OFFSET))
      (const_int LONG_CBRANCH_LENGTH)
        (if_then_else (gt (minus (match_dup 0) (pc))
                          (const_int MAX_SHORT_BRANCH_OFFSET))
          (const_int LONG_CBRANCH_LENGTH)
          (const_int SHORT_CBRANCH_LENGTH)))
  ] (const_int DEFAULT_INSN_LENGTH)))


;;
;; The default attributes for 'asm' statements.
;; The default length is the longest possible single 6809 instruction,
;; which is 4 bytes.  GCC will automatically multiply this by the
;; number of real insns contained in an asm statement.
;;
(define_asm_attributes
  [(set_attr "length" "4")
   (set_attr "type" "unknown")])

;;
;; An attribute for the number of cycles that it takes an instruction
;; to execute.
;;
(define_attr "cycles" "" (const_int DEFAULT_INSN_CYCLES))


;;--------------------------------------------------------------------
;;- Instruction patterns.  When multiple patterns apply,
;;- the first one in the file is chosen.
;;-
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;-
;;- Note: NOTICE_UPDATE_CC in m6809.h handles condition code updates
;;- for most instructions.
;;--------------------------------------------------------------------

;;--------------------------------------------------------------------
;;-  Test
;;--------------------------------------------------------------------

(define_insn "tsthi"
  [(set (cc0) (match_operand:HI 0 "register_operand" "ad"))]
  ""
  "cmp%0\t#0"
   [(set_attr "length" "4")])


(define_insn "*bitqi3_and"
  [(set (cc0)
    (and:QI (match_operand:QI 0 "register_operand" "%q,q")
      (match_operand:QI 1 "general_operand"         "i,mt")))]
  ""
  "@
   bit%0\t%1
   bit%0\t%1"
  [(set_attr "length" "2,3")])


(define_insn "*bitqi3_zero_extract"
  [(set (cc0)
    (zero_extract:HI (match_operand:QI 0 "general_operand" "q")
      (match_operand:HI 1 "const_int_operand" "i")
      (match_operand:HI 2 "const_int_operand" "i")))]
  ""
{
  rtx xoperands[2];
  unsigned int mask;

  mask = ((1 << INTVAL(operands[1])) - 1) << INTVAL(operands[2]);

  xoperands[0] = operands[0];
  xoperands[1] = gen_rtx_CONST_INT (QImode, mask);
  output_asm_insn ("bit%0\t%1", xoperands);
  return "";
}
  [(set_attr "length" "3")])


(define_insn "tstqi"
  [(set (cc0) (match_operand:QI 0 "nonimmediate_operand" "q,mt"))]
  ""
  "@
   tst%0
   tst\t%0"
   [(set_attr "length" "1,3")])

;;--------------------------------------------------------------------
;;- Compare
;;--------------------------------------------------------------------

;;- cmphi for register to memory or register compares
(define_insn "cmphi"
  [(set (cc0)
    (compare
      (match_operand:HI 0 "general_operand" "da, mi, ??Ud")
      (match_operand:HI 1 "general_operand" "mi, da,  dU")))]
  ""
{
  if ((REG_P (operands[0])) && (REG_P (operands[1]))) {
    output_asm_insn ("pshs\t%1\t;cmphi: R:%1 with R:%0", operands);
    return "cmp%0\t,s++\t;cmphi:";
  }
  if (GET_CODE (operands[0]) == REG)
    return "cmp%0\t%1\t;cmphi:";
  else {
    cc_status.flags |= CC_REVERSED;
    return "cmp%1\t%0\t;cmphi:(R)";
  }
}
  [(set_attr "length" "5,5,7")])


(define_insn "cmpqi"
  [(set (cc0)
    (compare (match_operand:QI 0 "whole_general_operand" "q,q, q,O,mt,K")
    (match_operand:QI 1 "whole_general_operand"          "O,mt,K,q,q, q")))]
  ""
{
    if (REG_P (operands[0]) && !M_REG_P (operands[0]))
    {
      if (operands[1] == const0_rtx)
        return "tst%0\t;cmpqi:(ZERO)";
      else
        return "cmp%0\t%1\t;cmpqi:";
    }
    else
    {
      cc_status.flags |= CC_REVERSED;

      if (operands[0] == const0_rtx)
        return "tst%1\t;cmpqi:(RZERO)";
      else
        return "cmp%1\t%0\t;cmpqi:(R)";
    }
}
   [(set_attr "length" "1,3,2,1,3,2")])


;;--------------------------------------------------------------------
;;-  Move
;;--------------------------------------------------------------------

; this looks good (obviously not finished) but I still see 'movsi'
; places in udivsi3 where it's broken
; (define_insn "pushsi1"
;   [(set (mem:SI (pre_dec (reg:HI HARD_S_REGNUM)))
;         (match_operand:SI 0 "general_operand" "o"))
;    (set (reg:HI HARD_S_REGNUM)
;         (plus:HI (reg:HI HARD_S_REGNUM) (const_int -4))) ]
;   ""
;   "; pushsi %0"
;    [(set_attr "length" "12")])
;
; (define_insn "popsi1"
;   [(set (match_operand:SI 0 "general_operand" "=o")
;         (mem:SI (post_inc (reg:HI HARD_S_REGNUM))))
;    (set (reg:HI HARD_S_REGNUM)
;         (plus:HI (reg:HI HARD_S_REGNUM) (const_int 4))) ]
;   ""
;   "; popsi %0"
;    [(set_attr "length" "12")])

; (define_insn "movsi"
;   [(set (match_operand:SI 0 "nonimmediate_operand" "=o")
;         (match_operand:SI 1 "general_operand"      " oi"))]
;   ""
;   "; movsi %0 <- %1"
;    [(set_attr "length" "1")])

; this doesn't work
; (define_expand "movsi"
;   [(parallel [
;      (set (match_operand:SI 0 "nonimmediate_operand" "")
;           (match_operand:SI 1 "general_operand" ""))
;      (clobber (match_scratch:HI 2 ""))])]
;   ""
; {
;   rtx insn;
;   if (STACK_PUSH_P (operands[0]) || STACK_POP_P (operands[1]))
;   {
;     REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC, stack_pointer_rtx, REG_NOTES (insn));
;   }
;   insn = emit_move_multi_word (SImode, operands[0], operands[1]);
;   DONE;
; })


(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
    (match_operand:HI 1 "general_operand" ""))]
  ""
{
  /* One of the ops has to be in a register prior to reload */
  if (!register_operand (operand0, HImode) &&
      !register_operand (operand1, HImode))
    operands[1] = copy_to_mode_reg (HImode, operand1);
})

;;; Try a splitter to handle failure cases where we try to move
;;; an immediate constant (zero usually) directly to memory.
;;; This absolutely requires an intermediate register.
(define_split
  [(set (match_operand:HI 0 "memory_operand" "")
    (match_operand:HI 1 "immediate_operand"  ""))
   (clobber (match_operand:HI 2 "register_operand" ""))]
  ""
  [(set (match_dup 2) (match_dup 1))
   (set (match_dup 0) (match_dup 2))]
  "")


;;; This would be a nice method for loading from a word array,
;;; but it is never generated because the combiner cannot merge
;;; more than 3 instructions (there are four here).  This is
;;; perhaps better done via a peephole.
(define_insn "*movhi_array_load"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=da")
    (mem:HI (plus:HI (ashift:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%B")) (const_int 1))
                     (match_operand:HI 2 "immediate_operand" "i"))))
   (clobber (match_scratch:HI 3 "=v"))]
  ""
  "ldx\t%2\;abx\;abx\;ld%0\t,x"
   [(set_attr "length" "7")])


;;; Optimize the move of a byte to the stack using the pshs instruction
;;; instead of a store with pre-increment.
(define_insn "movhi_push"
  [(set (match_operand:HI 0 "push_operand" "=m")
    (match_operand:HI 1 "register_operand" "U"))]
  ""
  "pshs\t%1"
  [(set_attr "length" "2")])


(define_insn "*movhi_pic_symbolref"
  [(set (match_operand:HI 0 "register_operand" "=a")
    (match_operand:HI 1 "symbolic_operand" ""))]
  "flag_pic"
  "lea%0\t%c1,pcr"
   [(set_attr "length" "4")])


(define_insn "*movhi_1"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=a,d,a,ad,tmu")
    (match_operand:HI 1 "general_operand"          " a,a,d,tmiu,ad"))]
  ""
  "@
   lea%0\t,%1
   tfr\t%1,%0
   tfr\t%1,%0
   ld%0\t%1
   st%1\t%0"
   [(set_attr "length" "2,2,2,*,*")])


;;; Generated by the combiner to merge an address calculation with
;;; a byte load.  We can use the 'abx' instruction here.
(define_insn "*movqi_array_load"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=q")
    (mem:QI (plus:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%B"))
                     (match_operand:HI 2 "immediate_operand" "i"))))
   (clobber (match_scratch:HI 3 "=v"))]
  ""
  "ldx\t%2\;abx\;ld%0\t,x"
   [(set_attr "length" "6")])


;;; Optimize the move of a byte to the stack using the pshs instruction
;;; instead of a store with pre-increment.
(define_insn "movqi_push"
  [(set (match_operand:QI 0 "push_operand" "=m")
    (match_operand:QI 1 "register_operand" " q"))]
  ""
  "pshs\t%1"
  [(set_attr "length" "2")])


;;; Optimize the move of a byte from the stack using the puls instruction
;;; instead of a store with post-decrement.
(define_insn "movqi_pop"
  [(set (match_operand:QI 0 "register_operand" "=q")
    (match_operand:QI 1 "pop_operand" "m"))]
  ""
  "puls\t%0"
  [(set_attr "length" "2")])


;;- load low byte of 16-bit data into 8-bit register/memory
(define_insn "*mov_lsb"
  [(set (match_operand:QI 0 "nonimmediate_operand"    "=q,q,q,m,!q")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,m,a,d, U") 1))]
  ""
  "@
   \t;movlsbqihi: D->B
   ld%0\t%L1\t;movlsbqihi: msb:%1 -> R:%0
   tfr\t%1,d\t;movlsbqihi: R:%1 -> R:%0
   stb\t%0\t;movlsbqihi: R:%1 -> %0
   pshs\t%1\t;movlsbqihi: R:%1 -> R:%0\;leas\t1,s\;puls\t%0"
   [(set_attr "length" "0,*,2,*,6")])


;;- load high byte of 16-bit data into 8-bit register/memory
(define_insn "*mov_msb"
  [(set (match_operand:QI 0 "nonimmediate_operand"    "=q,q,q,q,m,!q")
      (subreg:QI (match_operand:HI 1 "general_operand" "d,O,a,m,d, U") 0))]
  ""
  "@
   tfr\ta,b\t;movmsbqihi: D->B
   clr%0\t\t;movmsbqihi: ZERO -> R:%0
   tfr\t%1,d\t;movmsbqihi: R:%1 -> R:%0\;tfr\ta,b
   ld%0\t%L1\t;movmsbqihi: lsb:%1 -> R:%0
   sta\t%0\t;movmsbqihi: R:%1 -> %0
   pshs\t%1\t;movmsbqihi: R:%1 -> R:%0\;puls\t%0\;leas\t1,s"
  [(set_attr "length" "2,1,4,*,*,6")])


(define_insn "*movqi_boolean"
  [(set (reg:QI HARD_Z_REGNUM)
    (match_operand:QI 0 "general_operand" "q,O,i,m"))]
  ""
  "@
   tst%0
   andcc\t#~4
   orcc\t#4
   tst\t%0")


(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=q,q,tm,q,tm,q,z,q")
    (match_operand:QI 1 "general_operand"          " q,O,O,tmi,q,z,q,c"))]
  ""
  "@
   tfr\t%1,%0
   clr%0
   clr\t%0
   ld%0\t%1
   st%1\t%0
   tfr\tcc,%0\;and%0\t#4
   tst%0
   tfr\t%1,%0\t;movqi R:%1 -> R:%0"
   [(set_attr "length" "2,1,3,*,*,4,1,2")])


;;--------------------------------------------------------------------
;;-  Swap registers
;;--------------------------------------------------------------------

; Note: 8-bit swap is never needed so it is not defined.

(define_insn "swaphi"
  [(set (match_operand:HI 0 "register_operand" "+r")
    (match_operand:HI 1 "register_operand" "+r"))
   (set (match_dup 1) (match_dup 0))]
  ""
  "exg\t%1,%0"
  [(set_attr "length" "2")
   (set (attr "cycles") (const_int EXG_CYCLES))])


(define_insn "bswaphi2"
  [(set (match_operand:HI 0 "register_operand" "=d")
    (bswap:HI (match_operand:HI 1 "register_operand" "0")))]
  ""
  "exg\ta,b"
  [(set_attr "length" "2")])


;;--------------------------------------------------------------------
;;-  Extension and truncation insns.
;;--------------------------------------------------------------------

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=d")
        (sign_extend:HI (match_operand:QI 1 "general_operand" "B")))]
  ""
  "sex\t\t;extendqihi2: R:%1 -> R:%0"
  [(set_attr "length" "1")])


(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=d")
        (zero_extend:HI (match_operand:QI 1 "general_operand" "B")))]
  ""
  "clra\t\t;zero_extendqihi: R:%1 -> R:%0"
  [(set_attr "length" "1")])


;;--------------------------------------------------------------------
;;- All kinds of add instructions.
;;--------------------------------------------------------------------


;;
;; gcc's automatic version of addsi3 doesn't know about adcb,adca
;; so it is MUCH less efficient.  Define this one ourselves.
;;
;; TODO - can't always get 'd' for the clobber... allow other registers
;; as well and use exg d,R ... exg R,d around the code sequence to
;; use others, at a price.  Also consider libcall for this when
;; optimizing for size.
;;
(define_insn "addsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"  "=o")
     (plus:SI (match_operand:SI 1 "general_operand" "%o")
        (match_operand:SI 2 "general_operand"       " oi")))
   (clobber (match_scratch:HI 3 "=d"))]
  ""
{
  m6809_output_addsi3 (PLUS, operands);
  return "";
}
  [(set_attr "length" "21")])


; Increment of a 16-bit MEM by 1 can be done without a register.
(define_insn "*addhi_mem_1"
  [(set (match_operand:HI 0 "memory_operand" "=m")
        (plus:HI (match_dup 0) (const_int 1)))]
   "GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF"
{
  rtx xoperands[2];

  xoperands[0] = operands[0];
  xoperands[1] = adjust_address (operands[0], QImode, 1);

  output_asm_insn ("inc\t%1", xoperands);
  output_asm_insn ("bne\t__IL%=", xoperands);
  output_asm_insn ("inc\t%0\;__IL%=:", xoperands);
  return "";
}
  [(set_attr "length" "7")])


; Decrement of a 16-bit MEM by 1 can be done without a register.
(define_insn "*addhi_mem_minus1"
  [(set (match_operand:HI 0 "memory_operand" "=m")
        (plus:HI (match_dup 0) (const_int -1)))]
   "GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF"
{
  rtx xoperands[2];

  xoperands[0] = operands[0];
  xoperands[1] = adjust_address (operands[0], QImode, 1);

  output_asm_insn ("tst\t%1", xoperands);
  output_asm_insn ("bne\t__IL%=", xoperands);
  output_asm_insn ("dec\t%0", xoperands);
  output_asm_insn ("__IL%=:", xoperands);
  output_asm_insn ("dec\t%1", xoperands);
  return "";
}
  [(set_attr "length" "7")])


; Allow the addition of an 8-bit quantity to a 16-bit quantity
; using the LEAX B,Y addressing mode, where X and Y are both
; index registers.  This will only get generated via the peephole
; which removes a sign extension.
(define_insn "*addhi_b"
  [(set (match_operand:HI 0 "index_register_operand"       "=a")
    (plus:HI(match_operand:HI 1 "index_register_operand"   "%a")
    (match_operand:QI 2 "register_operand"                  "q")
  ))]
  ""
  "lea%0\t%2,%1\t;addhi_b: R:%0 = R:%2 + R:%1"
  [(set_attr "length" "*")])


; Splitter for addhi pattern #5 below
(define_split
  [(set (match_operand:HI 0 "index_register_operand" "")
    (plus:HI (match_dup 0) (match_operand:HI 1 "memory_operand" "")))]
  "reload_completed"
  [
   (parallel [(set (match_dup 0) (reg:HI HARD_D_REGNUM))
              (set (reg:HI HARD_D_REGNUM) (match_dup 0))])
   (set (reg:HI HARD_D_REGNUM)
        (plus:HI (reg:HI HARD_D_REGNUM) (match_dup 1)))
   (parallel [(set (match_dup 0) (reg:HI HARD_D_REGNUM))
              (set (reg:HI HARD_D_REGNUM) (match_dup 0))])
   ]
{
})


; Splitter for addhi pattern #7 below
(define_split
  [(set (match_operand:HI 0 "index_register_operand" "")
    (plus:HI (match_dup 0) (match_operand:HI 1 "index_register_operand" "")))]
  "reload_completed"
  [
   (parallel [(set (match_dup 1) (reg:HI HARD_D_REGNUM))
              (set (reg:HI HARD_D_REGNUM) (match_dup 1))])
   (set (match_dup 0)
        (plus:HI (reg:HI HARD_D_REGNUM) (match_dup 0)))
   (parallel [(set (match_dup 1) (reg:HI HARD_D_REGNUM))
              (set (reg:HI HARD_D_REGNUM) (match_dup 1))])
   ]
{
})


; TODO - this is ugly.  During RTL generation, we don't know what registers
; are available, so the multiple-insn sequences can only be solved
; via 'define_split's during matching.  See andhi3 for an example.
; Keep the constraints with ? modifiers to help reload pick the right
; registers.
;
; The forms are:
; 1. D += D, expand this into a shift instead. (rtx costs should be corrected
; to avoid this even happening...)
; 2. D += U, require U to be pushed to memory.  (Lots of patterns do this
; now, is this a better way?)
; 3. Best choice: 'addd'
; 4. Next best choice: 'lea'
; 5. Hybrid of 3 and 4
; 6. Same as 4, not bad
; 7. BAD, no D register at all
; 8. 'lea', as good as 4.
(define_insn "addhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand"      "=d, d,  d,  a,?a, a,???T,a")
    (plus:HI(match_operand:HI 1 "add_general_operand"   "%0, 0,  0,  d, 0, a, 0, a")
    (match_operand:HI 2 "general_operand"               " 0, !U, mi, a, m, d, T, i")
  ))]
  ""
  "@
   lslb\t\t;addhi: R:%0 += R:%2\;rola\t\t;also R:%0 *= 2
   pshs\t%2\t;addhi: R:%0 += R:%2\;add%0\t,s++
   add%0\t%2
   lea%0\t%1,%2
   #
   lea%0\t%2,%1
   #
   lea%0\t%a2,%1"
   [(set_attr "length" "2,6,*,*,7,*,7,*")])


(define_insn "addqi3_carry"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=q")
    (unspec:QI [
      (match_operand:QI 1 "whole_general_operand" "%0")
      (match_operand:QI 2 "whole_general_operand" "tmi")] UNSPEC_ADD_CARRY))]
  ""
  "adc%0\t%2\t;addqi_carry: R:%0 += %2"
  [(set_attr "length" "*")])


; TODO: specifying 'A' for the first constraint, to force into the A register
; is not working because of the way registers are currently set up.  This will
; take some work to get right.  Thus the second alternative as a backup.
(define_insn "addqi3_decimal"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=A,?q")
    (unspec:QI [
      (match_operand:QI 1 "general_operand"        "%0,0")
      (match_operand:QI 2 "general_operand"        "tmi,tmi")] UNSPEC_ADD_DECIMAL))]
  ""
  "@
   adda\t%2\;daa
   tfr\t%0,a\;adda\t%2\;daa\;tfr\ta,%0"
  [(set_attr "length" "5,9")])


(define_insn "addqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand"       "=q, q, q, q, tm, tm, q,  q")
    (plus:QI (match_operand:QI 1 "whole_general_operand" "%0, 0, 0, 0, 0,  0,  0,  0")
    (match_operand:QI 2 "whole_general_operand"          " 0, I, N, i, I,  N,  tm, q")))]
  ""
  "@
   asl%0\t\t;addqi: R:%0 = R:%0 + R:%0
   inc%0
   dec%0
   add%0\t%2
   inc\t%0
   dec\t%0
   add%0\t%2
   pshs\t%2\t;addqi: R:%0 -= R:%2\;add%0\t,s+"
  [(set_attr "length" "1,1,1,2,3,3,3,4")])


;;--------------------------------------------------------------------
;;- Subtract instructions.
;;--------------------------------------------------------------------

(define_insn "subsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand"  "=o")
     (minus:SI (match_operand:SI 1 "general_operand" " o")
        (match_operand:SI 2 "general_operand"       " oi")))
   (clobber (match_scratch:HI 3 "=d"))]
  ""
{
  m6809_output_addsi3 (MINUS, operands);
  return "";
}
  [(set_attr "length" "21")])


(define_insn "subhi3"
  [(set (match_operand:HI 0 "register_operand"      "=d,  d, a")
    (minus:HI (match_operand:HI 1 "register_operand" "0,  0, 0")
    (match_operand:HI 2 "general_operand"            "mi, ?U,n")))]
  ""
  "@
   sub%0\t%2\t;subhi: R:%0 -= %2
   pshs\t%2\t;subhi: R:%0 -= R:%2\;sub%0\t,s++
   lea%0\t%n2,%1\t;subhi: R:%0 = R:%1 + %n2"
   [(set_attr "length" "*,5,3")])


(define_insn "subqi3_carry"
  [(set (match_operand:QI 0 "register_operand" "=q")
    (unspec:QI [
      (match_operand:QI 1 "whole_general_operand" "%0")
      (match_operand:QI 2 "whole_general_operand" "tmi")] UNSPEC_SUB_CARRY))]
  ""
  "sbc%0\t%2\t;subqi_carry: R:%0 += %2"
  [(set_attr "length" "*")])


(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand"            "=q, q, !q, !q, !q,  q,  q")
    (minus:QI (match_operand:QI 1 "whole_register_operand" "0, 0,  I,  i,  tm, 0,  0")
    (match_operand:QI 2 "whole_general_operand"            "I, i,  0,  0,  0,  tm, q")))]
  ""
  "@
   dec%0
   sub%0\t%2
   dec%0\;neg%0
   sub%0\t%1\;neg%0
   sub%0\t%1\;neg%0
   sub%0\t%2
   pshs\t%2\t;subqi: R:%0 -= R:%2\;sub%0\t,s+"
   [(set_attr "length" "1,2,2,3,4,3,4")])


;;--------------------------------------------------------------------
;;- Multiply instructions.
;;--------------------------------------------------------------------

; TODO - merge these two instructions, using 'extend_operator' to match
; either signed or zero extension.  Everything else is the same.
(define_insn "mulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=d")
      (mult:HI (sign_extend:HI (match_operand:QI 1 "general_operand" "%q"))
      (match_operand:QI 2 "general_operand" "tmK")))]
  ""
  "lda\t%2\t;mulqihi3\;mul"
  [(set_attr "length" "3")])


(define_insn "umulqihi3"
   [(set (match_operand:HI 0 "register_operand" "=d")
    (mult:HI (zero_extend:HI (match_operand:QI 1 "general_operand" "%q"))
    (match_operand:QI 2 "general_operand" "tmK")))]
  ""
  "lda\t%2\t;umulqihi3\;mul"
  [(set_attr "length" "3")])


; Expand a 16x16 multiplication into either a libcall or a shift.
; If the second operand is a small constant, use the above form.
; Otherwise, do a libcall.
(define_expand "mulhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
    (mult:HI (match_operand:HI 1 "general_operand" "")
    (match_operand:HI 2 "nonmemory_operand" "")))]
  ""
{
  emit_libcall_insns (HImode, "mulhi3", operands, 2);
  DONE;
})


;;--------------------------------------------------------------------
;;- Divide instructions.
;;--------------------------------------------------------------------

(define_expand "divhi3"
  [(set (match_operand:HI 0 "register_operand" "")
    (div:HI (match_operand:HI 1 "register_operand" "")
    (match_operand:HI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (HImode, "divhi3", operands, 2);
  DONE;
})


(define_expand "divqi3"
  [(set (match_operand:QI 0 "register_operand" "")
    (div:QI (match_operand:QI 1 "register_operand" "")
    (match_operand:QI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (QImode, "divqi3", operands, 2);
  DONE;
})


(define_expand "udivhi3"
  [(set (match_operand:HI 0 "register_operand" "")
     (udiv:HI (match_operand:HI 1 "register_operand" "")
              (match_operand:HI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (HImode, "udivhi3", operands, 2);
  DONE;
})


;;--------------------------------------------------------------------
;;- mod
;;--------------------------------------------------------------------

(define_expand "modhi3"
  [(set (match_operand:HI 0 "register_operand" "")
    (mod:HI (match_operand:HI 1 "register_operand" "")
    (match_operand:HI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (HImode, "modhi3", operands, 2);
  DONE;
})


(define_expand "modqi3"
  [(set (match_operand:QI 0 "register_operand" "")
    (mod:QI (match_operand:QI 1 "register_operand" "")
    (match_operand:QI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (QImode, "modqi3", operands, 2);
  DONE;
})


(define_expand "umodhi3"
  [(set (match_operand:HI 0 "register_operand" "")
    (umod:HI (match_operand:HI 1 "register_operand" "")
    (match_operand:HI 2 "register_operand" "")))]
  ""
{
  emit_libcall_insns (HImode, "umodhi3", operands, 2);
  DONE;
})



;;--------------------------------------------------------------------
;;- and, or, xor common patterns
;;--------------------------------------------------------------------

; Split a bitwise HImode into two QImode instructions, with one of
; the sources in a pushable register.  The register is pushed onto
; the stack and memory pop operands (,s+) are used in the QI forms.
(define_split
  [(set (match_operand:HI 0 "register_operand" "")
    (match_operator:HI 3 "logical_bit_operator"
      [(match_operand:HI 1 "register_operand" "")
       (match_operand:HI 2 "register_operand" "")]))]
  "reload_completed"
  [(set (mem:HI (pre_dec:HI (reg:HI HARD_S_REGNUM))) (match_dup 2))
   (set (reg:QI HARD_A_REGNUM) (match_op_dup:QI 3
         [(reg:QI HARD_A_REGNUM)
          (mem:QI (post_inc:QI (reg:HI HARD_S_REGNUM)))]))
   (set (reg:QI HARD_D_REGNUM) (match_op_dup:QI 3
         [(reg:QI HARD_D_REGNUM)
          (mem:QI (post_inc:QI (reg:HI HARD_S_REGNUM)))]))
   (use (reg:QI HARD_A_REGNUM))]
{
})

; Split a bitwise HImode into two QImode instructions, with one
; of the sources being a (MEM (MEM (...)); i.e. an indirect memory
; reference.  This requires dereferencing the pointer into a
; temporary register (X), which must be saved/restored around the
; compute instructions.
(define_split
  [(set (match_operand:HI 0 "register_operand" "")
    (match_operator:HI 3 "logical_bit_operator"
      [(match_operand:HI 1 "register_operand" "")
       (mem:HI (match_operand:HI 2 "memory_operand" ""))]))]
  "reload_completed"
  [
   (set (mem:HI (pre_dec:HI (reg:HI HARD_S_REGNUM))) (match_dup 4))
   (set (match_dup 4) (match_dup 2))
   (set (match_dup 4) (mem:HI (match_dup 4)))
   (set (reg:QI HARD_A_REGNUM) (match_op_dup:QI 3
         [(reg:QI HARD_A_REGNUM)
          (mem:QI (post_inc:QI (match_dup 4)))]))
   (set (reg:QI HARD_D_REGNUM) (match_op_dup:QI 3
         [(reg:QI HARD_D_REGNUM)
          (mem:QI (post_inc:QI (match_dup 4)))]))
   (use (reg:QI HARD_A_REGNUM))
   (set (match_dup 4) (mem:HI (post_inc:HI (reg:HI HARD_S_REGNUM))))
   ]
{
  /* Use X for a temporary index register */
  operands[4] = gen_rtx_REG (HImode, HARD_X_REGNUM);
})

; Split a bitwise HImode into two QImode instructions.  This is
; the common case.  This handles splitting when neither of the
; above two cases applies.
(define_split
  [(set (match_operand:HI 0 "register_operand" "")
    (match_operator:HI 3 "logical_bit_operator"
      [(match_operand:HI 1 "register_operand" "")
       (match_operand:HI 2 "general_operand" "")]))]
  "reload_completed"
  [(set (reg:QI HARD_A_REGNUM) (match_op_dup:QI 3
      [(reg:QI HARD_A_REGNUM) (match_dup 4)]))
   (set (reg:QI HARD_D_REGNUM) (match_op_dup:QI 3
      [(reg:QI HARD_D_REGNUM) (match_dup 5)]))
   (use (reg:QI HARD_A_REGNUM))]
{
  if (GET_CODE (operands[2]) == CONST_INT)
  {
    operands[4] = gen_rtx_const_high (operands[2]);
    operands[5] = gen_rtx_const_low (operands[2]);
  }
  else if ((GET_CODE (operands[2]) == MEM)
    && (GET_CODE (XEXP (operands[2], 0)) == MEM))
  {
    FAIL;
  }
  else
  {
    rtx reg, addr = operands[2];
    if (MEM_P (addr) && GET_CODE (XEXP (addr, 0)) == POST_INC &&
        GET_CODE ((reg = XEXP (XEXP (addr, 0), 0))) == REG) {
      operands[4] = gen_rtx_MEM (QImode, gen_rtx_POST_INC (BLKmode, reg));
      operands[5] = gen_rtx_MEM (QImode, gen_rtx_PLUS (HImode, reg, GEN_INT (-1)));
    }
    else
    if (MEM_P (addr) && GET_CODE (XEXP (addr, 0)) == PRE_DEC &&
        GET_CODE ((reg = XEXP (XEXP (addr, 0), 0))) == REG) {
      operands[4] = gen_rtx_MEM (QImode, gen_rtx_PRE_DEC (BLKmode, reg));
      operands[5] = gen_rtx_MEM (QImode, gen_rtx_PLUS (HImode, reg, GEN_INT (1)));
    }
    else {
      operands[4] = gen_highpart (QImode, addr);
      operands[5] = gen_lowpart (QImode, addr);
    }
  }
})


; Below are the specific cases for each of the operators.
; The QImode versions are the simplest and can be implemented
; directly on the hardware.  The HImode cases are all output
; using one of the above splitting techniques.

;;--------------------------------------------------------------------
;;- and
;;--------------------------------------------------------------------

(define_insn "andhi3"
  [(set (match_operand:HI 0 "register_operand" "=d")
    (and:HI (match_operand:HI 1 "register_operand" "%0")
    (match_operand:HI 2 "general_operand" "mnU")))]
  ""
  "#")


(define_insn "andqi3"
  [(set (match_operand:QI 0 "register_operand"           "=q,q,q,qc")
    (and:QI (match_operand:QI 1 "whole_register_operand" "%0,0,0,0")
    (match_operand:QI 2 "whole_general_operand"          " O,N,tm,i")))]
  ""
  "@
   clr%0\t;andqi(ZERO)
   \t;andqi(-1)
   and%0\t%2
   and%0\t%2"
   [(set_attr "length" "1,0,3,2")])


;;--------------------------------------------------------------------
;;- or
;;--------------------------------------------------------------------

(define_insn "iorhi3"
  [(set (match_operand:HI 0 "register_operand" "=d")
    (ior:HI (match_operand:HI 1 "register_operand" "%0")
    (match_operand:HI 2 "general_operand" "mnU")))]
  ""
  "#")


(define_insn "iorqi3"
  [(set (match_operand:QI 0 "register_operand"           "=q,q, qc")
    (ior:QI (match_operand:QI 1 "whole_register_operand" "%0,0, 0")
    (match_operand:QI 2 "whole_general_operand"          " O,tm,i")))]
  ""
  "@
   \t;iorqi(ZERO)
   or%0\t%2
   or%0\t%2"
   [(set_attr "length" "0,3,2")])

;;--------------------------------------------------------------------
;;- xor
;;--------------------------------------------------------------------

(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=d")
    (xor:HI (match_operand:HI 1 "register_operand" "%0")
    (match_operand:HI 2 "general_operand" "mnU")))]
  ""
  "#")


(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand"           "=q,q,q,q")
    (xor:QI (match_operand:QI 1 "whole_register_operand" "%0,0,0,0")
    (match_operand:QI 2 "whole_general_operand"          " O,N,tm,i")))]
  ""
  "@
   \t;xorqi(ZERO)
   com%0\t;xorqi(-1)
   eor%0\t%2
   eor%0\t%2"
   [(set_attr "length" "0,1,3,2")])

;;--------------------------------------------------------------------
;;-  Two's Complements
;;--------------------------------------------------------------------

(define_insn "neghi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,!a")
    (neg:HI (match_operand:HI 1 "general_operand"   "0, 0")))]
  ""
  "@
   nega\;negb\;sbca\t#0
   exg\td,%0\;nega\;negb\;sbca\t#0\;exg\td,%0"
  [(set_attr "length" "5,9")])


(define_insn "negqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand"    "=q,m")
    (neg:QI (match_operand:QI 1 "nonimmediate_operand" "0,0")))]
  ""
  "@
   neg%0
   neg\t%0"
  [(set_attr "length" "1,3")])


;;--------------------------------------------------------------------
;;-  One's Complements
;;--------------------------------------------------------------------

(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=d,?tm,???a")
    (not:HI (match_operand:HI 1 "general_operand"   "0,  0,   0")))]
  ""
  "@
   coma\;comb
   com\t%0\;com\t%L0
   exg\td,%0\;coma\;comb\;exg\td,%0"
  [(set_attr "length" "2,6,6")])


(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand"    "=q,tm")
    (not:QI (match_operand:QI 1 "nonimmediate_operand" "0,0")))]
  ""
  "@
   com%0
   com\t%0"
  [(set_attr "length" "1,3")])

;;--------------------------------------------------------------------
;;- Shifts/rotates
;;--------------------------------------------------------------------

(define_code_iterator bit_code [ashift ashiftrt lshiftrt])
(define_code_attr bit_code_name [(ashift "ashl") (ashiftrt "ashr") (lshiftrt "lshr")])

(define_mode_iterator bit_mode [QI HI])
(define_mode_attr bit_mode_name [(QI "qi3") (HI "hi3")])

;; Emit RTL for any shift (handles all 3 opcodes and 2 mode sizes)

(define_expand "<bit_code:bit_code_name><bit_mode:bit_mode_name>"
  [(set (match_operand:bit_mode 0 "nonimmediate_operand" "")
    (bit_code:bit_mode (match_operand:bit_mode 1 "general_operand" "")
    (match_operand:bit_mode 2 "nonmemory_operand" "")))]
  ""
{
})

; Individual instructions implemented in the CPU.


(define_insn "*ashift1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,q")
    (ashift:QI (match_operand:QI 1 "general_operand" "0,0") (const_int 1)))]
  ""
  "@
   asl\t%0
   asl%0"
  [(set_attr "length" "3,1")])

(define_insn "*lshiftrt1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,q")
    (lshiftrt:QI (match_operand:QI 1 "general_operand" "0,0") (const_int 1)))]
  ""
  "@
   lsr\t%0
   lsr%0"
  [(set_attr "length" "3,1")])

(define_insn "*ashiftrt1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,q")
    (ashiftrt:QI (match_operand:QI 1 "general_operand" "0,0") (const_int 1)))]
  ""
  "@
   asr\t%0
   asr%0"
  [(set_attr "length" "3,1")])

(define_insn "*rotate1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,q")
    (rotate:QI (match_operand:QI 1 "general_operand" "0,0") (const_int 1)))]
  ""
  "@
   rol\t%0
   rol%0"
  [(set_attr "length" "3,1")])


(define_insn "*rotatert1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,q")
    (rotatert:QI (match_operand:QI 1 "general_operand" "0,0") (const_int 1)))]
  ""
  "@
   ror\t%0
   ror%0"
  [(set_attr "length" "3,1")])


; A shift by 8 for D reg can be optimized by just moving
; between the A/B halves, and then zero/sign extending or
; filling in zeroes.
; Because GCC does not understand that 'A' and 'D' refer to
; the same storage location, we must use 'USE' throughout
; to prevent deletion of 'unnecessary' instructions.
; Similar optimization for MEM would require a scratch register
; so is not done here.

(define_split
  [(set (reg:HI HARD_D_REGNUM) (ashift:HI (reg:HI HARD_D_REGNUM) (const_int 8)))]
  "reload_completed"
  [
   (use (reg:HI HARD_D_REGNUM))
   (set (reg:QI HARD_A_REGNUM) (reg:QI HARD_D_REGNUM))
   (use (reg:QI HARD_A_REGNUM))
   (set (reg:QI HARD_D_REGNUM) (const_int 0))
   ]
  "")

(define_split
  [(set (reg:HI HARD_D_REGNUM) (lshiftrt:HI (reg:HI HARD_D_REGNUM) (const_int 8)))]
  "reload_completed"
  [
   (use (reg:HI HARD_D_REGNUM))
   (set (reg:QI HARD_D_REGNUM) (reg:QI HARD_A_REGNUM))
   (use (reg:QI HARD_D_REGNUM))
   (set (reg:HI HARD_D_REGNUM) (zero_extend:HI (reg:QI HARD_D_REGNUM)))
   ]
  "")

(define_split
  [(set (reg:HI HARD_D_REGNUM) (ashiftrt:HI (reg:HI HARD_D_REGNUM) (const_int 8)))]
  "reload_completed"
  [
   (use (reg:HI HARD_D_REGNUM))
   (set (reg:QI HARD_D_REGNUM) (reg:QI HARD_A_REGNUM))
   (use (reg:QI HARD_D_REGNUM))
   (set (reg:HI HARD_D_REGNUM) (sign_extend:HI (reg:QI HARD_D_REGNUM)))
   ]
  "")


; On the WPC hardware, there is a shift register that can be used
; to compute (1<<n) efficiently in two instructions.  Note that this
; form only works when using -mint8 though, because C will promote
; to 'int' when doing this operation.  TODO : we need a 16-bit form too.
(define_insn "ashlqi3_wpc"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=q")
    (ashift:QI (match_operand:QI 1 "immediate_operand" "I")
    (match_operand:QI 2 "general_operand" "q")))]
  "TARGET_WPC"
  "st%2\t0x3FF7\;ld%0\t0x3FF7"
  [(set_attr "length" "6")])


; Internal instructions for shifting by a constant.
; Two forms are provided, one for QImode, one for HImode.
; These are always split into the above instructions
; (except for QImode forms that directly match one of the
; above instructions, in which the condition will not
; allow the splitter to match).

(define_insn_and_split "<bit_code:bit_code_name>hi3_const"
  [(set (match_operand:HI 0 "nonimmediate_operand"     "=dm")
    (bit_code:HI (match_operand:HI 1 "general_operand" "0")
    (match_operand:HI 2 "immediate_operand"            "n")))]
  ""
  "#"
  "reload_completed"
  [(const_int 0)]
{
  m6809_split_shift (<bit_code:CODE>, operands);
  DONE;
})


(define_insn_and_split "<bit_code:bit_code_name>qi3_const"
  [(set (match_operand:QI 0 "nonimmediate_operand"     "=qm")
    (bit_code:QI (match_operand:QI 1 "general_operand" "0")
    (match_operand:QI 2 "immediate_operand"            "n")))]
  "INTVAL (operands[2]) != 1"
  "#"
  "&& reload_completed"
  [(const_int 0)]
{
  m6809_split_shift (<bit_code:CODE>, operands);
  DONE;
})

; Internal instructions for shifting by a nonconstant.
; These expand into complex assembly.

(define_insn "<bit_code:bit_code_name>hi3_reg"
  [(set (match_operand:HI 0 "nonimmediate_operand"     "=d")
    (bit_code:HI (match_operand:HI 1 "general_operand" "0")
    (match_operand:HI 2 "nonimmediate_operand"         "v")))]
  ""
{
  m6809_output_shift_insn (<bit_code:CODE>, operands);
  return "";
}
  [(set_attr "length" "20")])


(define_insn "<bit_code:bit_code_name>qi3_reg"
  [(set (match_operand:QI 0 "nonimmediate_operand"    "=q")
    (bit_code:QI (match_operand:QI 1 "general_operand" "0")
    (match_operand:QI 2 "nonimmediate_operand"         "v")))]
  ""
{
  m6809_output_shift_insn (<bit_code:CODE>, operands);
  return "";
}
  [(set_attr "length" "16")])



;;--------------------------------------------------------------------
;;-  Jumps and transfers
;;--------------------------------------------------------------------

;;; The casesi pattern is normally *not* defined; see 'tablejump' instead.
(define_expand "casesi"
  [(match_operand:HI 0 "register_operand" "")   ; index to jump on
   (match_operand:HI 1 "immediate_operand" "")   ; lower bound
   (match_operand:HI 2 "immediate_operand" "")   ; total range
   (match_operand 3 "" "")   ; table label
   (match_operand 4 "" "")]  ; out of range label
  "TARGET_BYTE_INT && TARGET_CASESI"
{
  m6809_do_casesi (operands[0], operands[1], operands[2],
                   operands[3], operands[4]);
  DONE;
})

(define_insn "tablejump_short_offset"
  [(set (pc)
       (mem:HI (plus:HI (match_operand:HI 1 "register_operand" "U")
                (zero_extend:HI (match_operand:QI 0 "register_operand" "q")))))]
  ""
  "jmp\t[b,x]\t;tablejump_short_offset"
  [(set_attr "length" "3")])

(define_insn "tablejump_long_offset"
  [(set (pc)
       (mem:HI (plus:HI (match_operand:HI 1 "register_operand" "U")
                (match_operand:HI 0 "register_operand" "d"))))]
  ""
  "jmp\t[d,x]\t;tablejump_long_offset"
  [(set_attr "length" "3")])


 ;; A tablejump operation gives the address in operand 0, with the
 ;; CODE_LABEL for the table in operand 1.  The 'define_expand'
 ;; shows the arguments as GCC presents them.  For a register
 ;; operand, the assembly code is straightforward.  For a MEM,
 ;; assumed to be a SYMBOL_REF, two forms are given, one normal
 ;; and one for PIC mode.
 (define_expand "tablejump"
    [(parallel [
     (set (pc) (match_operand:HI 0 "" ""))
     (use (label_ref (match_operand 1 "" "")))
     (clobber (match_scratch:HI 2 ""))
     ])]
    ""
 {
 })


(define_insn "*tablejump_reg"
   [(parallel [
      (set (pc)
         (match_operand:HI 0 "register_operand" "a"))
      (use (label_ref (match_operand 1 "" "")))
      (clobber (match_scratch:HI 2 ""))
      ])]
   ""
   "jmp\t,%0"
   [(set_attr "length" "3")])


(define_insn "*tablejump_symbol"
  [(parallel [
     (set (pc)
        (mem:HI
           (plus:HI (match_operand:HI 0 "register_operand" "a")
                    (label_ref (match_operand 1 "" "")))))
     (use (label_ref (match_dup 1)))
     (clobber (match_scratch:HI 2 ""))
     ])]
  "!flag_pic"
{
  output_asm_insn ("jmp\t[%a1,%0]", operands);
  return "";
}
  [(set_attr "length" "4")])


(define_insn "*tablejump_symbol_pic"
  [(parallel [
     (set (pc)
        (mem:HI
           (plus:HI (match_operand:HI 0 "register_operand" "d")
                    (label_ref (match_operand 1 "" "")))))
     (use (label_ref (match_dup 1)))
     (clobber (match_scratch:HI 2 "=&a"))
     ])]
  "flag_pic"
{
  output_asm_insn ("lea%2\t%a1,pcr", operands);
  output_asm_insn ("ld%0\t%0,%2", operands);
  output_asm_insn ("jmp\t%0,%2", operands);
  return "";
}
  [(set_attr "length" "8")])


(define_insn "indirect_jump"
  [(set (pc)
    (match_operand:HI 0 "register_operand" "a"))]
  ""
  "jmp\t,%0"
  [(set_attr "length" "3")])


(define_insn "jump"
  [(set (pc) (label_ref (match_operand 0 "" "")))]
  ""
{
  return output_branch_insn ( LABEL_REF, operands, get_attr_length (insn));
}
  [(set (attr "type") (const_string "branch"))])


; Output assembly for a condition branch instruction.
(define_insn "*cond_branch"
  [(set (pc)
    (if_then_else
      (match_operator 1 "comparison_operator" [(cc0) (const_int 0)])
        (label_ref (match_operand 0 "" "")) (pc)))]
  ""
{
  return output_branch_insn ( GET_CODE(operands[1]),
    operands, get_attr_length (insn));
}
  [(set (attr "type") (const_string "cbranch"))])


; Similar to above, but for a condition branch instruction that
; had its operands reversed at some point.
(define_insn "*cond_branch_reverse"
  [(set (pc)
    (if_then_else
      (match_operator 1 "comparison_operator" [(cc0) (const_int 0)])
      (pc) (label_ref (match_operand 0 "" ""))))]
  ""
{
  return output_branch_insn ( reverse_condition (GET_CODE(operands[1])),
    operands, get_attr_length (insn));
}
  [(set (attr "type") (const_string "cbranch"))])


;; These are only used for RTL generation; the above patterns will
;; generate the assembly code.
(define_insn "beq" [(set (pc) (if_then_else (eq (cc0) (const_int 0))
  (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bne" [(set (pc) (if_then_else (ne (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bgt" [(set (pc) (if_then_else (gt (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bgtu" [(set (pc) (if_then_else (gtu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "blt" [(set (pc) (if_then_else (lt (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bltu" [(set (pc) (if_then_else (ltu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bge" [(set (pc) (if_then_else (ge (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bgeu" [(set (pc) (if_then_else (geu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "ble" [(set (pc) (if_then_else (le (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")

(define_insn "bleu" [(set (pc) (if_then_else (leu (cc0) (const_int 0))
      (label_ref (match_operand 0 "" "")) (pc)))] "" "")


;;--------------------------------------------------------------------
;;-  Calls
;;--------------------------------------------------------------------

;; Generate a call instruction for a function that does not
;; return a value.  The expander is used during RTL generation.
;; The instructions below are used during matching; only one
;; of them will be used, depending on the type of function
;; being called.  The different conditions are:
;;
;;    1) far_functionp - is this a far function?  Those need
;;    to be output as indirect calls through a far-function
;;    handler.
;;
;;    2) SIBLING_CALL_P (insn) ?  If so,
;;    we can use a 'jmp' instead of a 'jsr' to call it.
;;
;;    3) is PIC mode enabled?  If so, we'll always use
;;    relative calls (lbsr or lbra).
;;
;; Note: not all combinations are fully supported, especially
;; relating to PIC.
;;
;; The 'bsr' instruction is never generated.

(define_expand "call"
  [(call (match_operand:HI 0 "memory_operand" "")
    (match_operand:HI 1 "general_operand" ""))]
  ""
  "")

(define_insn "*call_nopic_far"
  [(call (match_operand:HI 0 "memory_operand" "m")
    (match_operand:HI 1 "general_operand" "g"))]
  "far_functionp (operands[0])"
{
  output_far_call_insn (operands, 0);
  return "";
}
  [(set_attr "length" "6")])


; PIC forms come first, and should only match
; (MEM (SYMBOL_REF)).  Other MEM forms are treated as usual.
(define_insn "*call_pic"
  [(call (mem:HI (match_operand:HI 0 "symbolic_operand" ""))
    (match_operand:HI 1 "general_operand" "g"))]
  "flag_pic && !SIBLING_CALL_P (insn)"
  "lbsr\t%C0"
  [(set_attr "length" "3")])


(define_insn "*call_nopic"
  [(call (match_operand:HI 0 "memory_operand" "m")
    (match_operand:HI 1 "general_operand" "g"))]
  "!SIBLING_CALL_P (insn)"
{
  output_call_insn (&operands[0]);
  return "";
}
  [(set_attr "length" "3")
   (set (attr "cycles") (const_int JSR_EXTENDED_CYCLES))])


(define_insn "*call_noreturn_pic"
  [(call (mem:HI (match_operand:HI 0 "symbolic_operand" ""))
    (match_operand:HI 1 "general_operand" "g"))]
  "flag_pic && SIBLING_CALL_P (insn)"
  "lbra\t%C0"
  [(set_attr "length" "3")])


(define_insn "*call_noreturn_nopic"
  [(call (match_operand:HI 0 "memory_operand" "m")
    (match_operand:HI 1 "general_operand" "g"))]
  "SIBLING_CALL_P (insn)"
  "jmp\t%0"
  [(set_attr "length" "3")])


;;
;; Same as above, but for functions that do return a value.
;;
(define_expand "call_value"
  [(set (match_operand 0 "" "")
    (call (match_operand:HI 1 "memory_operand" "")
    (match_operand:HI 2 "general_operand" "")))]
  ""
  "")


(define_insn "*call_value_far"
  [(set (match_operand 0 "" "=gz")
    (call (match_operand:HI 1 "memory_operand" "m")
    (match_operand:HI 2 "general_operand" "g")))]
  "far_functionp (operands[1])"
{
  output_far_call_insn (operands, 1);
  return "";
}
  [(set_attr "length" "6")])


(define_insn "*call_value_pic"
  [(set (match_operand 0 "" "=gz")
    (call (mem:HI (match_operand:HI 1 "symbolic_operand" ""))
    (match_operand:HI 2 "general_operand" "g")))]
  "flag_pic"
  "lbsr\t%C1"
  [(set_attr "length" "3")])


(define_insn "*call_value_nopic"
  [(set (match_operand 0 "" "=gz")
    (call (match_operand:HI 1 "memory_operand" "m")
    (match_operand:HI 2 "general_operand" "g")))]
  ""
{
  output_call_insn (&operands[1]);
  return "";
}
  [(set_attr "length" "3")
   (set (attr "cycles") (const_int JSR_EXTENDED_CYCLES))])



;;
;; How to generate an untyped call.
;;
(define_expand "untyped_call"
  [(parallel [(call (match_operand 0 "" "")
        (const_int 0))
      (match_operand 1 "" "")
      (match_operand 2 "" "")])]
  ""
{
  int i;

  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));
  for (i=0; i < XVECLEN (operands[2], 0); i++)
  {
    rtx set = XVECEXP (operands[2], 0, i);
    emit_move_insn (SET_DEST (set), SET_SRC (set));
  }
  emit_insn (gen_blockage ());
  DONE;
})


(define_expand "sibcall"
  [(parallel
     [(call (match_operand:HI 0 "memory_operand" "")
            (match_operand:HI 1 "immediate_operand" ""))
      (use (reg:HI HARD_PC_REGNUM))])]
  ""
  "")

(define_insn "*sibcall_1"
  [(parallel
     [(call (match_operand:HI 0 "memory_operand" "m")
            (match_operand:HI 1 "immediate_operand" "i"))
      (use (reg:HI HARD_PC_REGNUM))])]
  "SIBLING_CALL_P(insn)"
  "jmp\t%0"
  [(set_attr "length" "4")])


(define_expand "sibcall_value"
  [(parallel
     [(set (match_operand 0 "" "")
         (call (match_operand:HI 1 "memory_operand" "")
               (match_operand:HI 2 "immediate_operand" "")))
      (use (reg:HI HARD_PC_REGNUM))])]
  ""
  "")

(define_insn "*sibcall_value_1"
  [(parallel
     [(set (match_operand 0 "" "=gz")
         (call (match_operand:HI 1 "memory_operand" "m")
               (match_operand:HI 2 "immediate_operand" "i")))
      (use (reg:HI HARD_PC_REGNUM))])]
  "SIBLING_CALL_P(insn)"
  "jmp\t%1"
  [(set_attr "length" "4")])


;;--------------------------------------------------------------------
;;-  Function Entry and Exit
;;--------------------------------------------------------------------

;; On entry to a function, the stack frame looks as follows:
;; - return address (pushed by the caller)
;; - saved registers
;; - local variable storage
;;
;; If the function does not modify the stack after that, then
;; any of these can be accessed directly as an offset from
;; STACK_POINTER_REGNUM.  Otherwise, a frame pointer is required.
;; In that case, the prologue must also initialize HARD_FRAME_POINTER_REGNUM
;; and all references to the stack frame will use that as a base instead.
;;
(define_expand "prologue"
  [(const_int 0)]
  "prologue_epilogue_required ()"
{
  emit_prologue_insns ();
  DONE;
})


;; The function epilogue does exactly the reverse of the prologue,
;; deallocating local variable space, restoring saved registers,
;; and returning.
;;
;; For the 6809, the return may be 'rti' if the function was
;; declared as an interrupt function, but is normally 'rts'.
;;
;; Also, as an optimization, the register restore and the 'rts'
;; can be combined into a single instruction, by adding 'PC' to the
;; list of registers to be restored.  This is only done if there are
;; any saved registers, as 'rts' is more efficient by itself.
;;
(define_expand "epilogue"
  [(const_int 0)]
  "prologue_epilogue_required ()"
{
  emit_epilogue_insns (false);
  DONE;
})


(define_expand "sibcall_epilogue"
  [(const_int 0)]
  "prologue_epilogue_required ()"
{
  emit_epilogue_insns (true);
  DONE;
})


;; The RTS instruction
(define_insn "return_rts"
  [(return)
   (use (reg:HI HARD_PC_REGNUM))]
  "!m6809_current_function_has_type_attr_p (\"interrupt\")
   && m6809_get_live_regs () == 0"
  "rts"
  [(set_attr "length" "1")
   (set (attr "cycles") (const_int RTS_CYCLES))])

(define_insn "return_puls_pc"
  [(return)
   (use (reg:HI HARD_PC_REGNUM))]
  "!m6809_current_function_has_type_attr_p (\"interrupt\")
   && m6809_get_live_regs () != 0"
  ""
  [(set_attr "length" "1")
   (set (attr "cycles") (const_int RTS_CYCLES))])

;; The RTI instruction
(define_insn "return_rti"
  [(return)
   (use (reg:HI HARD_PC_REGNUM))]
  "m6809_current_function_has_type_attr_p (\"interrupt\")"
  "rti"
  [(set_attr "length" "1")
   (set (attr "cycles") (const_int RTI_CYCLES))])


;;--------------------------------------------------------------------
;;-  Unspecified instructions
;;--------------------------------------------------------------------

;; An instruction that has the effect of an unspec_volatile, but
;; which doesn't require emitting any assembly code.
(define_insn "blockage"
  [(unspec_volatile [(const_int 0)] UNSPEC_BLOCKAGE)]
  ""
  ""
  [(set_attr "length" "0")
   (set (attr "cycles") (const_int 0))])


;; Say how to push multiple registers onto the stack, using
;; the 6809 'pshs' instruction.  The operand is a regset
;; specifying which registers to push.
;;
;; The operand mode is not given intentionally, so as to allow
;; any possible integer mode for the regset.
;;
;; See below for a peephole that can combine consecutive push
;; instructions that qualify for merging.
(define_insn "register_push"
  [(use (reg:HI HARD_S_REGNUM))
    (unspec_volatile
      [(match_operand 0 "immediate_operand" "")] UNSPEC_PUSH_RS)
    (clobber (reg:HI HARD_S_REGNUM))]
  ""
  "pshs\t%R0"
  [(set_attr "length" "2")
   (set (attr "cycles") (const_int PSH_PUL_CYCLES))])


;; Say how to pop multiple registers from the stack, using
;; the 6809 'puls' instruction.  The operand is the register
;; bitset value.
(define_insn "register_pop"
  [(use (reg:HI HARD_S_REGNUM))
    (unspec_volatile
      [(match_operand 0 "immediate_operand" "")] UNSPEC_POP_RS)
    (clobber (reg:HI HARD_S_REGNUM))]
  ""
  "puls\t%R0"
  [(set_attr "length" "2")
   (set (attr "cycles") (const_int PSH_PUL_CYCLES))])


(define_insn "m6809_swi"
  [(unspec_volatile
    [(match_operand:QI 0 "immediate_operand" "I,n")] UNSPEC_SWI)]
  ""
  "@
   swi
   swi%c0"
  [(set_attr "length" "1,2")
   (set (attr "cycles") (const_int SWI_CYCLES))])


;; Generate the CWAI instruction
(define_insn "m6809_cwai"
  [(unspec_volatile
    [(match_operand:QI 0 "immediate_operand" "")] UNSPEC_CWAI)]
  ""
  "cwai\t%0"
  [(set_attr "length" "2")
   (set (attr "cycles") (const_int CWAI_CYCLES))])


;; Generate the SYNC instruction
(define_insn "m6809_sync"
  [(unspec_volatile [(const_int 0)] UNSPEC_SYNC)]
  ""
  "sync"
  [(set_attr "length" "1")
   (set (attr "cycles") (const_int SYNC_CYCLES))])


;; Generate the MUL instruction
(define_insn "m6809_mul"
  [(set (match_operand:HI 0 "register_operand" "=d")
    (unspec:HI [
      (match_operand:QI 1 "general_operand" "%B")
      (match_operand:QI 2 "general_operand" "tmi")] UNSPEC_MUL))]
  ""
  "lda\t%2\n\tmul"
  [(set_attr "length" "4")
   (set (attr "cycles") (const_int MUL_CYCLES))])


;; Generate the NOP instruction
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
   [(set_attr "length" "1")
   (set (attr "cycles") (const_int NOP_CYCLES))])


;;--------------------------------------------------------------------
;;- Peepholes
;;--------------------------------------------------------------------

;;; Each peephole has an ID that is used for debugging.
;;; Each peephole condition is bracketed by calls to
;;; m6809_match_peephole2() also for debugging.
(define_constants [
  (PEEP_END 0)
  (PEEP_COND 1)

  (PEEP_STACK_STORE_INC 0)
  (PEEP_STACK_CLEAR_INC 1)
  (PEEP_LSRB_ADCB 2)
  (PEEP_ABX 3)
  (PEEP_ABX2 4)
  (PEEP_INDEXED_INC 5)
  (PEEP_MEM_DEC 6)
  (PEEP_MEM_INC 7)
  (PEEP_MEM_DEC_CMP 8)
  (PEEP_PUSH2 9)
  (PEEP_STORE_IMPLIES_CC 10)
  (PEEP_DEC_IMPLIES_CC 11)
  (PEEP_LEAB 12)
  (PEEP_LDX_INDIRECT 13)
  (PEEP_POP_JUNK 14)
])


;;; Optimize 'leas -1,s' followed by 'stb ,s'.  This can happen if the
;;; function prologue needs to allocate stack space and 'b' is placed
;;; into that local right away.  Combine the stack allocation with the
;;; store using preincrement mode.
(define_peephole2
  [(set (reg:HI HARD_S_REGNUM)
        (plus:HI (reg:HI HARD_S_REGNUM) (const_int -1)))
   (set (mem:QI (reg:HI HARD_S_REGNUM)) (reg:QI HARD_D_REGNUM))]
  ""
  [(set (mem:QI (pre_dec:HI (reg:HI HARD_S_REGNUM))) (reg:QI HARD_D_REGNUM))]
  "")


;;; Same as above, but for a 'clr ,s' that follows the prologue.
(define_peephole2
  [(set (reg:HI HARD_S_REGNUM) (plus:HI (reg:HI HARD_S_REGNUM) (const_int -1)))
   (set (mem:QI (reg:HI HARD_S_REGNUM)) (const_int 0))]
  ""
  [(set (mem:QI (pre_dec:HI (reg:HI HARD_S_REGNUM))) (const_int 0))]
  "")

;;; Similar to the above, but for 'ldb ,s' followed by 'leas 1,s'; this
;;; typically occurs in the function epilogue.

(define_peephole2
  [(set (reg:QI HARD_D_REGNUM) (mem:QI (reg:HI HARD_S_REGNUM)))
   (set (reg:HI HARD_S_REGNUM)
        (plus:HI (reg:HI HARD_S_REGNUM) (const_int 1)))]
  ""
  [(set (reg:QI HARD_D_REGNUM) (mem:QI (post_inc:HI (reg:HI HARD_S_REGNUM))))]
  "")

;;; Merge two consecutive push instructions into a single register_push.
(define_peephole2
  [(set (match_operand 0 "push_operand" "")
    (match_operand 1 "register_operand" ""))
   (set (match_operand 2 "push_operand" "")
    (match_operand 3 "register_operand" ""))]
  "m6809_match_peephole2 (PEEP_PUSH2, PEEP_COND)
   && reload_completed
   && GET_MODE (operands[1]) == GET_MODE (operands[3])
   && m6809_can_merge_pushpop_p (UNSPEC_PUSH_RS, 1 << REGNO (operands[1]), 1 << REGNO (operands[3]))
   && m6809_match_peephole2 (PEEP_PUSH2, PEEP_END)"
  [(parallel [
    (use (reg:HI HARD_S_REGNUM))
    (unspec_volatile [(match_dup 4)] UNSPEC_PUSH_RS)
    (clobber (reg:HI HARD_S_REGNUM))])
   (use (match_dup 1))
   (use (match_dup 3))]
{
  operands[4] = gen_rtx_CONST_INT (QImode,
    (1 << REGNO (operands[1])) | (1 << REGNO (operands[3])));
})


;;; Convert 'stX ,--s' into a push instruction.  Use the regset
;;; notation, so that it may be combined with an adjacent regset.
;;; TBD - this doesn't compile some code cleanly.
;(define_peephole2
;  [(set (mem:HI (pre_dec:HI (reg:HI HARD_S_REGNUM)))
;        (reg:HI HARD_X_REGNUM))]
;  "reload_completed"
;  [(parallel [
;    (use (reg:HI HARD_S_REGNUM))
;    (unspec_volatile [(match_dup 0)] UNSPEC_PUSH_RS)
;    (clobber (reg:HI HARD_S_REGNUM))])]
;{
;  operands[0] = gen_rtx_CONST_INT (HImode, X_REGBIT);
;})


;;;
;;; q = (q+1)/2 can be optimized as "lsrb; adcb".  This also
;;; won't overflow when q=0xFF.
;;; TODO : this form isn't accounting for promotion when
;;; using 16-bit ints.
;;;
(define_peephole
  [(set (reg:QI HARD_D_REGNUM)
    (lshiftrt:QI (plus:HI (match_dup 0) (const_int 1)) (const_int 1)))]
  "m6809_match_peephole2 (PEEP_LSRB_ADCB, PEEP_END)"
  "lsrb\;adcb\t#0; peephole"
  [(set_attr "length" "2")])


;;
;; Optimize the case of following a register store with a test
;; of reg or mem just moved.
;;
(define_peephole
  [(set (match_operand:HI 0 "memory_operand" "=m")
  (match_operand:HI 1 "register_operand" "r"))
   (set (cc0) (match_operand:HI 2 "general_operand" "g"))]
  "m6809_match_peephole2 (PEEP_STORE_IMPLIES_CC, PEEP_COND)
   && (operands[2] == operands[0] || operands[2] == operands[1])
   && m6809_match_peephole2 (PEEP_STORE_IMPLIES_CC, PEEP_END)"
  "st%1\t%0\t;movhi: R:%1 -> %0 w/ implied test of %2"
  [(set_attr "length" "4")])


;; Optimize a pair of SET instructions in which the second insn
;; is the reverse of the first one.  I.e.
;;
;; A = B
;;        ---->  A = B
;; B = A
;;
;; The second insn is redundant.  Define two patterns, one for QI, one for HI.
;; But don't do this if either is a VOLATILE MEM.
(define_peephole2
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
        (match_operand:HI 1 "nonimmediate_operand" ""))
  (set (match_dup 1) (match_dup 0))]
  "!MEM_P (operands[0]) || !MEM_P (operands[1]) || (!MEM_VOLATILE_P (operands[0]) && !MEM_VOLATILE_P (operands[1]))"
  [(set (match_dup 0) (match_dup 1))]
  "")

(define_peephole2
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
        (match_operand:QI 1 "nonimmediate_operand" ""))
  (set (match_dup 1) (match_dup 0))]
  "!MEM_P (operands[0]) || !MEM_P (operands[1]) || (!MEM_VOLATILE_P (operands[0]) && !MEM_VOLATILE_P (operands[1]))"
  [(set (match_dup 0) (match_dup 1))]
  "")


;;
;; Optimize the sum of an 8-bit and 16-bit using the 'abx' instruction
;; if B and X can be used.  Two patterns are provided to catch both
;; X=X+D and X=D+X.
;;
(define_peephole
  [(set (reg:HI HARD_D_REGNUM)
    (zero_extend:HI (match_operand:QI 0 "general_operand" "q")))
   (set (reg:HI HARD_X_REGNUM)
    (plus:HI (reg:HI HARD_D_REGNUM) (reg:HI HARD_X_REGNUM)))]
  "m6809_match_peephole2 (PEEP_ABX, PEEP_END)"
  "abx"
  [(set_attr "length" "1")])

(define_peephole
  [(set (reg:HI HARD_D_REGNUM)
    (zero_extend:HI (match_operand:QI 0 "general_operand" "q")))
   (set (reg:HI HARD_X_REGNUM)
    (plus:HI (reg:HI HARD_X_REGNUM) (reg:HI HARD_D_REGNUM)))]
  "m6809_match_peephole2 (PEEP_ABX, PEEP_END)"
  "abx"
  [(set_attr "length" "1")])

;;; Likewise, handle when B is scaled by 2 prior to the add.
;;; Instead of shifting B in 4 cycles, just do the ABX a second
;;; time, in only 3 cycles.

(define_peephole
  [(set (reg:HI HARD_D_REGNUM)
    (zero_extend:HI (match_operand:QI 0 "general_operand" "q")))
   (set (reg:HI HARD_D_REGNUM)
    (ashift:HI (reg:HI HARD_D_REGNUM) (const_int 1)))
   (set (reg:HI HARD_X_REGNUM)
    (plus:HI (reg:HI HARD_D_REGNUM) (reg:HI HARD_X_REGNUM)))]
  "m6809_match_peephole2 (PEEP_ABX2, PEEP_END)"
  "abx\;abx"
  [(set_attr "length" "2")])

(define_peephole
  [(set (reg:HI HARD_D_REGNUM)
    (zero_extend:HI (match_operand:QI 0 "general_operand" "q")))
   (set (reg:HI HARD_D_REGNUM)
    (ashift:HI (reg:HI HARD_D_REGNUM) (const_int 1)))
   (set (reg:HI HARD_X_REGNUM)
    (plus:HI (reg:HI HARD_X_REGNUM) (reg:HI HARD_D_REGNUM)))]
  "m6809_match_peephole2 (PEEP_ABX2, PEEP_END)"
  "abx\;abx"
  [(set_attr "length" "2")])


;;
;; Work around a compiler bug that generates bad code when copying
;; between 32-bit memory addresses after a libcall.  The problem seen is
;; that the source is MEM (REG X), but X is used as the reload register.
;; The second half of the copy therefore fails.
;;
;; The solution is to switch the reload register to D, since that is guaranteed
;; not to be in use right after a libcall.
;;
(define_peephole2
  [(set (reg:HI HARD_X_REGNUM) (mem:HI (reg:HI HARD_X_REGNUM)))
   (set (match_operand:HI 0 "nonimmediate_operand" "") (reg:HI HARD_X_REGNUM))
   (set (reg:HI HARD_X_REGNUM)
      (mem:HI (plus:HI (reg:HI HARD_X_REGNUM) (const_int 2))))
   (set (match_operand:HI 1 "nonimmediate_operand" "") (reg:HI HARD_X_REGNUM))]
  "reload_completed"
  [(set (reg:HI HARD_D_REGNUM) (mem:HI (reg:HI HARD_X_REGNUM)))
   (set (match_dup 0) (reg:HI HARD_D_REGNUM))
   (set (reg:HI HARD_X_REGNUM)
      (mem:HI (plus:HI (reg:HI HARD_X_REGNUM) (const_int 2))))
   (set (match_dup 1) (reg:HI HARD_X_REGNUM))]
  "")


;; Turn "and then test" into a "bit test" operation.
;; Provide variants for immediate and memory sources
;; This is the most used peephople.
; (define_peephole
;   [(set (match_operand:QI 0 "register_operand" "=q")
;     (and:QI (match_operand:QI 1 "register_operand" "0")
;       (match_operand:QI 2 "immediate_operand" "i")))
;    (set (cc0) (match_dup 0))]
;   ""
;   "bit%0\t%2"
;   [(set_attr "length" "3")])
; 
; (define_peephole
;   [(set (match_operand:QI 0 "register_operand" "=q")
;     (and:QI (match_operand:QI 1 "register_operand" "0")
;       (match_operand:QI 2 "memory_operand" "m")))
;    (set (cc0) (match_dup 0))]
;   ""
;   "bit%0\t%2"
;   [(set_attr "length" "4")])


;; Turn a "decrement, then test" sequence into just a "decrement".
;; The test can be omitted, since it is implicitly done.
(define_peephole2
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
    (plus:QI (match_operand:QI 1 "whole_general_operand" "")
    (match_operand:QI 2 "immediate_operand" "")))
   (set (cc0) (match_dup 0))]
  "m6809_match_peephole2 (PEEP_DEC_IMPLIES_CC, PEEP_END)"
  [(set (match_dup 0) (plus:QI (match_dup 1) (match_dup 2)))]
  "")


;; Merge an indexed register increment with a previous usage.
;; This is usually done automatically, but not always
;; The 'use' should be optional; in all cases where this has been
;; seen, it is required though.
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
     (mem:QI (match_operand:HI 1 "index_register_operand" "")))
   (use (match_dup 0))
   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
  "m6809_match_peephole2 (PEEP_INDEXED_INC, PEEP_END)"
  [(set (match_dup 0) (mem:QI (post_inc:HI (match_dup 1))))
   (use (match_dup 0))]
  "")


;;; Merge "ldX MEM; ldX ,X" into a single instruction using
;;; the indirect mode.
(define_peephole2
  [(set (reg:HI HARD_X_REGNUM)
    (mem:HI (match_operand:HI 0 "general_operand" "")))
   (set (reg:HI HARD_X_REGNUM) (mem:HI (reg:HI HARD_X_REGNUM)))]
  "reload_completed && m6809_match_peephole2 (PEEP_LDX_INDIRECT, PEEP_END)"
  [(set (reg:HI HARD_X_REGNUM)
    (mem:HI (mem:HI (match_dup 0))))]
  "")


;;; Reorder a store followed by a unary operation on that memory
;;; so that the unary is performed and then the store.  Consider
;;; a binary shift operation, which will be decomposed into
;;; identical single shifts, also.
;;; TODO - recognize more than just 'ashift' here.
(define_peephole2
  [(set (match_operand:QI 0 "memory_operand" "")
        (match_operand:QI 1 "register_operand" ""))
   (set (match_dup 0)
        (ashift:QI (match_dup 0) (match_operand:QI 2 "immediate_operand")))]
  "reload_completed"
  [(set (match_dup 1)
        (ashift:QI (match_dup 1) (match_operand:QI 2 "immediate_operand")))
   (set (match_dup 0) (match_dup 1))]
  "")

;;; Likewise, reorder a unary MEM followed by a load, so that the load
;;; is done first, then use the REG instead of the MEM.
;;;(define_peephole2
;;;  [(set (match_dup 0)
;;;        (ashift:QI (match_dup 0) (match_operand:QI 2 "immediate_operand")))
;;;   (set (match_operand:QI 0 "register_operand" "")
;;;        (match_operand:QI 1 "memory_operand" ""))]
;;;  "reload_completed"
;;;  [(set (match_dup 0) (match_dup 1))
;;;   (set (match_dup 0)
;;;        (ashift:QI (match_dup 0) (match_operand:QI 2 "immediate_operand")))]
;;;  "")


;;; Replace sex; leaX d,Y with leaX b,Y.
;;;
(define_peephole2
  [(set (reg:HI HARD_D_REGNUM) (sign_extend:HI (reg:QI HARD_D_REGNUM)))
   (set (match_operand:HI 0 "index_register_operand" "")
        (plus:HI (match_operand:HI 1 "index_register_operand" "")
                 (reg:HI HARD_D_REGNUM)))]
  "reload_completed && m6809_match_peephole2 (PEEP_LEAB, PEEP_END)"
  [(set (match_dup 0)
        (plus:HI (match_dup 1) (reg:QI HARD_D_REGNUM)))]
  "")

(define_peephole2
  [(set (reg:HI HARD_D_REGNUM) (sign_extend:HI (reg:QI HARD_D_REGNUM)))
   (set (match_operand:HI 0 "index_register_operand" "")
        (plus:HI (reg:HI HARD_D_REGNUM)
          (match_operand:HI 1 "index_register_operand" "")))]
  "reload_completed && m6809_match_peephole2 (PEEP_LEAB, PEEP_END)"
  [(set (match_dup 0)
        (plus:HI (match_dup 1) (reg:QI HARD_D_REGNUM)))]
  "")


;;; Replace ldb; decb; stb; tstb with dec(mem).  If the
;;; register is not needed, then the load will get deleted
;;; automatically, but it may be needed for comparisons.
;;; Same for incb/inc.
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "nonimmediate_operand" ""))
   (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))
   (set (match_dup 1) (match_dup 0))
   (set (cc0) (match_dup 0))]
  "m6809_match_peephole2 (PEEP_MEM_DEC_CMP, PEEP_END)"
  [(set (match_dup 1) (plus:QI (match_dup 1) (const_int -1)))]
  "")


;;; Replace ldb; decb; stb with dec(mem); ldb.  If the
;;; register is not needed, then the load will get deleted
;;; automatically, but it may be needed for comparisons.
;;; Same for incb/inc.
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "nonimmediate_operand" ""))
   (set (match_dup 0) (plus:QI (match_dup 0) (const_int -1)))
   (set (match_dup 1) (match_dup 0))]
  "m6809_match_peephole2 (PEEP_MEM_DEC, PEEP_END)"
  [(set (match_dup 1) (plus:QI (match_dup 1) (const_int -1)))
   (set (match_dup 0) (match_dup 1))]
  "")

(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "nonimmediate_operand" ""))
   (set (match_dup 0) (plus:QI (match_dup 0) (const_int 1)))
   (set (match_dup 1) (match_dup 0))]
  "m6809_match_peephole2 (PEEP_MEM_INC, PEEP_END)"
  [(set (match_dup 1) (plus:QI (match_dup 1) (const_int 1)))
   (set (match_dup 0) (match_dup 1))]
  "")


;;; Replace "andb #N; cmpb #N; bhi" with "andb #N", if it can be proven
;;; that the branch can never occur because of the limited range of B.
;;; N must be a power of two for this to make sense.  This helps with
;;; the default cases of switch statements on a value (x & N).
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
    (and:QI (match_dup 0) (match_operand:QI 1 "immediate_operand" "")))
   (set (cc0)
    (compare (match_dup 0) (match_dup 1)))
   (set (pc) (if_then_else (gtu (cc0) (const_int 0)) (match_operand 2 "" "") (match_operand 3 "" "")))
   ]
  "reload_completed && power_of_two_p (INTVAL (operands[1]) + 1)"
  [(set (match_dup 0) (and:QI (match_dup 0) (match_dup 1)))]
  "")

;;; Replace ldd <mem>; addd #1; std <mem> with 16-bit increment
;;; of the mem, but only if D is dead.  Same for 16-bit decrement.
;;; <mem> must be offsettable for the instruction to match.
(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "") (match_operand:HI 1 "memory_operand" ""))
   (set (match_dup 0) (plus:HI (match_dup 0) (const_int 1)))
   (set (match_dup 1) (match_dup 0))]
   "reload_completed
    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
    && peep2_reg_dead_p (3, operands[0])"
  [(set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
  "")

(define_peephole2
  [(set (match_operand:HI 0 "register_operand" "") (match_operand:HI 1 "memory_operand" ""))
   (set (match_dup 0) (plus:HI (match_dup 0) (const_int -1)))
   (set (match_dup 1) (match_dup 0))]
   "reload_completed
    && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
    && peep2_reg_dead_p (3, operands[0])"
  [(set (match_dup 1) (plus:HI (match_dup 1) (const_int -1)))]
  "")


;;; Replace a load or store using an indexed register, followed by an increment of that
;;; register, with the combined form using autoincrement.
(define_peephole2
  [(set (match_operand:QI 0 "register_operand" "")
        (mem:QI (match_operand:HI 1 "index_register_operand" "")))
   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
   "reload_completed"
  [(set (match_dup 0) (mem:QI (post_inc (match_dup 1))))]
  "")


;;- mode:emacs-lisp
;;- comment-start: ";;- "
;;- eval: (set-syntax-table (copy-sequence (syntax-table)))
;;- eval: (modify-syntax-entry ?[ "(]")
;;- eval: (modify-syntax-entry ?] ")[")
;;- eval: (modify-syntax-entry ?{ "(}")
;;- eval: (modify-syntax-entry ?} "){")
;-; vim: set ts=2:
;-; vim: set expandtab:
;-; vim: set filetype=lisp:
;;- End:
